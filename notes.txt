---------------------------------------
PLAN / TODO
---------------------------------------
- work on client->master api
    - master reads init nodes from config file
    - PUT:
        - split incoming file into blocks
        - add entries to KBN 
        - distribute blocks to their requisite nodes

---------------------------------------
SCRIBBLES
---------------------------------------
MasterServer.route()
    if "/store":
        call StorageHandler.route()
        StoreHandler:
            GetHandler    
            PostHandler
            DeleteHandler

MasterServer:
    stores:
        - consistent hashing data structure
            - need for PUT, addNode and deleteNode 
        - KBN map



---------------------------------------
IMPLEMENTATION DETAILS
---------------------------------------

Master
------
- exposes GET/PUT/DELETE API
- breaks files into blocks and distributes across cluster of storage nodes
- uses consistent hashing to distribute blocks evenly

KBN:
    - master stores KEY -> {blockNum -> nodeNum} mapping
    - call this the KeyBlockNode map, or the KBN

HashRing:
    - nodes evenly distributed around ring of (2^32 - 1) values
    - use virtual nodes to ensure even distribution in 'low-node' environment
        - each physical node has N virtual nodes
        - blocks are assigned to a virtual node, which implictly assigns
          it to a physical node
    - flow:
        - add block (PUT):
            - compute hash(key + blockNum)
            - find nearest virtual node, which stores its physical node id
            - lookup in physical node table to find IP
        - add node:
            - 
        - delete node:
            -

API (client -> master):
    - endpoint: /store/{KEY}
    PUT:
        - receives (KEY, payload)
        - create entry in the KBN
        - breaks up payload into {block1, block2, ...}
        - for each block:
            - use consistent hashing (key+blockNum) to determine 
            which node stored on
            - send PUT to relevant node with (KEY, blockNum, blockPayload)
            - on success, add (blockNum->nodeNum) entry to KBN

    GET:
        - receives (KEY) to GET
        - lookup KEY entry in KBN
        - for each block:
            - send GET to relevant node with (KEY, blockNum)
            - add (in order) to a buffer
        - package up buffer into response payload

    DELETE:
        - receives (KEY) to DELETE
        - lookup KEY entry in KBN
        - for each block:
            - send DELETE to relevant node with (KEY, blockNum)

Other responsibilities:
    Adding/removing nodes
        - options:
            - manually (i.e. config file of ip:port addresses)
            - dynamically:
                - expose an API to add / remove nodes
                - only let authorised users make these calls

        - Adding:

        - Removing:
            - when remove a node, must re-assign all its blocks
              as per the consistent hashing strategy
    
    
    Checking health of nodes:
        - heartbeat method
        - send GET req to specialised heartbeat addr

Cluster
-------
- each cluster node just treated as a bucket of free/occupied blocks
- on disk format:
    Header:
        Magic Number - 4 bytes
        BAT offset - 4 bytes
        Block size - 4 bytes
    BAT:
        TBD
    Block 0
    Block 1
    ...
    Block N
API (master -> cluster node)
    GET:
        - receives (KEY, blockNum)
        - looks up offset in BAT
        - returns block

    PUT:
        - receives (KEY, blockNum, blockPayLoad)
        - inserts new BAT entry: (KEY, blockNum) -> offset
        - writes block at offset

    DELETE:
        - receives (KEY, blockNum)
        - removes BAT entry

Re-assignment:
    - when node added/deleted, blocks are re-assigned
    - this causes an update to the hash table, but blocks also need to be transferred
      between storage nodes
    - options:
        - node-node comm.:
            - i.e. storage nodes resolve this directly
            - probs don't want fully connected graph of storage nodes
        - master-node comm.:
            - expose addBlock/ and deleteBlock/ endpoints
            - i.e. for each re-assigned block:
                - send old node an deleteBlock/ req
                - send new node an addBlock/ req